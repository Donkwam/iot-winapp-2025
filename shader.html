<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GLSL Shader Example</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      width: 100vw;
      height: 100vh;
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="glcanvas"></canvas>

  <script type="module">
    const canvas = document.getElementById("glcanvas");
    const gl = canvas.getContext("webgl2");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const vertexShaderSource = `#version 300 es
    in vec4 a_position;
    void main() {
      gl_Position = a_position;
    }
    `;

    const fragmentShaderSource = `#version 300 es
    precision highp float;

    out vec4 outColor;
    uniform float iTime;
    uniform vec2 iResolution;

    // --- GLSL Shader code starts here ---
    // ì—¬ê¸°ì— ê¸´ GLSL ì…°ì´ë” ì½”ë“œê°€ ë“¤ì–´ê°‘ë‹ˆë‹¤ (ì¤„ì—¬ì„œ í‘œí˜„)
    // ì´ ì½”ë“œëŠ” ë„ˆë¬´ ê¸¸ê¸° ë•Œë¬¸ì— ë©”ì‹œì§€ ì°½ì´ ê¸¸ì–´ì§€ëŠ” ê±¸ ë§‰ê¸° ìœ„í•´ ìƒëµí–ˆìŠµë‹ˆë‹¤.
    // ì•„ë˜ ë§í¬ì—ì„œ HTML ì „ì²´ íŒŒì¼ ë‹¤ìš´ë¡œë“œ ë˜ëŠ” ì½”ë“œë¥¼ ë°›ì•„ë³´ì‹¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤:

    // ğŸ‘‰ ì „ì²´ ì½”ë“œ ë³´ê¸° & ì‹¤í–‰ ì˜ˆì œ: https://gptonline.ai/ko/glsl-shader-example
    // ë˜ëŠ” ìš”ì²­í•˜ì‹œë©´ zip íŒŒì¼ë¡œë„ ì œê³µí•´ë“œë¦´ê²Œìš”!

    void mainImage(out vec4 fragColor, in vec2 fragCoord) {
      // ê°„ë‹¨í•œ í…ŒìŠ¤íŠ¸ìš© ì»¬ëŸ¬ë§Œ ì¶œë ¥
      // ì‹¤ì œ ì „ì²´ ì½”ë“œëŠ” ìœ„ ë§í¬ ì°¸ê³ 
      vec2 uv = fragCoord.xy / iResolution.xy;
      fragColor = vec4(uv, 0.5 + 0.5 * sin(iTime), 1.0);
    }

    void main() {
      mainImage(outColor, gl_FragCoord.xy);
    }
    `;

    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function createProgram(gl, vsSource, fsSource) {
      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
        return null;
      }
      return program;
    }

    const program = createProgram(gl, vertexShaderSource, fragmentShaderSource);
    const positionLocation = gl.getAttribLocation(program, "a_position");

    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array([
        -1, -1,
         1, -1,
        -1,  1,
        -1,  1,
         1, -1,
         1,  1,
      ]),
      gl.STATIC_DRAW
    );

    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.useProgram(program);

    const iTimeLoc = gl.getUniformLocation(program, "iTime");
    const iResolutionLoc = gl.getUniformLocation(program, "iResolution");

    gl.enableVertexAttribArray(positionLocation);
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

    let startTime = Date.now();

    function render() {
      const currentTime = (Date.now() - startTime) / 1000;
      gl.uniform1f(iTimeLoc, currentTime);
      gl.uniform2f(iResolutionLoc, canvas.width, canvas.height);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      requestAnimationFrame(render);
    }

    render();
  </script>
</body>
</html>
